// Chat.service.ts

  // This starts the whole websocket process
  // Needs either targetRoomId or [targetUserId]. not both, not none.
  async startChat(targetUserId?: string[], targetRoomId?: string) {
    // If there is an active roomId when opening websocket connection, the previous connection closes
    if (this.ws && this.ws.readyState !== WebSocket.CLOSED) {
      console.warn(
        'Existing WebSocket detected. Closing it before starting a new one.',
      );
      await this.exitRoom(this.currentRoomId ?? '');
    }

    return new Promise<void>((resolve, reject) => {
      this.ws = new WebSocket(this.uri); // Creates new websocket connection

      // Activates when a successful connection between server and client has been made
      this.ws.onopen = () => {
        // Tells the server to create/enter a room with either targetUserIds or chatRoomId, depending on how the startChat() was called.
        if (targetUserId && !targetRoomId) {
          console.log('TARGETUSERIDDDDDDD: ', targetUserId);
          this.ws!.send(
            JSON.stringify({
              action: 'enterroom',
              targetUserId,
            }),
          );
        } else if (targetRoomId && !targetUserId) {
          this.ws!.send(
            JSON.stringify({
              action: 'enterroom',
              targetRoomId,
            }),
          );
        }
        console.log('Websocket connection successful');
        resolve(); // Tests require this for tracking the methodx's process
      };

      // Activates when the websocket server sends a message
      this.ws.onmessage = (e) => {
        console.log('Message: ', e);

        try {
          // Parses the message to usable form
          const msg = JSON.parse(e.data);
          this.currentRoomId = msg.RoomId;
          // The backend sends 2 kind of messages. The first type is sent when the user joins a new room.
          // The second type is sent when the user sends a message inside of a room.
          // If the e.data has senderId and message on it, it means that the received action is a message being sent.
          if (msg.SenderId && msg.Content) {
            // Uses addLog to show the received message in the frontend
            this.addLog(msg);
            // If the e.data has roomId on it, it means that the received action is about joining a new room.
          } else if (msg.roomId) {
            // Routes the user to the new room in frontend
            this.router.navigate(['/dashboard/social', msg.roomId]);

            this.logMessagesSubject.next([]);

            // Gets the chat history of a room and adds it to the chat messages$, that holds the chatlogs
            this.messageService.getMessages(msg.roomId).subscribe({
              next: (messages) => {
                console.log('yhistääÄÄÄä', messages);
                const current = this.logMessagesSubject.getValue();
                this.logMessagesSubject.next([...messages, ...current]);
              },
              error: (err) => {
                console.error('Failed to fetch messages:', err);
              },
            });
          }
        } catch (err) {
          console.error('Failed to parse message', e.data);
        }
      };

      // In case of an unexpected error, this ends the whole startChat process.
      this.ws.onerror = (err) => reject(err);

      // Sends a message to the user when the websocket connection is cut.
      this.ws.onclose = () =>
        this.addLog({
          SenderId: 'system',
          SenderUsername: 'system',
          Content: 'Connection closed',
          ProfilePicture: 'assets/svg/Acount.svg',
          Timestamp: Date.now(),
        });
    });
  }